import networkx as nx

def kruskal_mst(city):
    """
    Implements Kruskal's algorithm to find the Minimum Spanning Tree.
    
    The MST connects all bin locations in a way that minimizes the total
    distance/cost while ensuring all locations are reachable.
    
    Args:
        city: City object with graph representation
        
    Returns:
        networkx.Graph: A graph representing the Minimum Spanning Tree
    """
    # Create a new graph for the MST
    mst = nx.Graph()
    
    # Add all nodes from the original graph
    for node in city.graph.nodes():
        mst.add_node(node, **city.graph.nodes[node])
    
    # Get all edges sorted by weight
    edges = sorted(city.graph.edges(data=True), key=lambda x: x[2]['weight'])
    
    # Union-Find data structure for detecting cycles
    parent = {node: node for node in city.graph.nodes()}
    
    def find(node):
        """Find the representative of the set containing node."""
        if parent[node] != node:
            parent[node] = find(parent[node])  # Path compression
        return parent[node]
    
    def union(node1, node2):
        """Union the sets containing node1 and node2."""
        root1 = find(node1)
        root2 = find(node2)
        parent[root2] = root1
    
    # Kruskal's algorithm: add edges in order of increasing weight
    # as long as they don't create cycles
    for u, v, data in edges:
        if find(u) != find(v):  # If adding this edge doesn't create a cycle
            mst.add_edge(u, v, **data)  # Add edge to MST
            union(u, v)  # Merge the sets
    
    return mst

def get_kruskal_mst_routes(city):
    """
    Get routes based on the MST generated by Kruskal's algorithm.
    
    This is a basic approach that can be used as a foundation for more
    sophisticated routing strategies.
    
    Args:
        city: City object with graph representation
        
    Returns:
        dict: A dictionary mapping truck routes (lists of bin IDs) to total distances
    """
    # Generate MST
    mst = kruskal_mst(city)
    
    # Create routes by depth-first traversal of the MST
    visited = set()
    routes = []
    
    def dfs_traverse(node, current_route):
        """Recursive DFS traversal to create routes."""
        visited.add(node)
        current_route.append(node)
        
        for neighbor in mst.neighbors(node):
            if neighbor not in visited:
                dfs_traverse(neighbor, current_route)
    
    # Start DFS from each unvisited high priority bin
    high_priority_bins = city.get_high_priority_bins()
    
    # First traverse from high priority bins
    for bin_id in high_priority_bins:
        if bin_id not in visited:
            current_route = []
            dfs_traverse(bin_id, current_route)
            if current_route:
                routes.append(current_route)
    
    # Then traverse from any remaining unvisited nodes
    for node in mst.nodes():
        if node not in visited and not any(node.startswith('facility') for node in mst.nodes()):
            current_route = []
            dfs_traverse(node, current_route)
            if current_route:
                routes.append(current_route)
    
    # Calculate distances for each route
    route_distances = {}
    for i, route in enumerate(routes):
        total_distance = 0
        for j in range(len(route) - 1):
            # Get the weight of the edge in the MST
            total_distance += mst[route[j]][route[j+1]]['weight']
        route_distances[f"route_{i}"] = (route, total_distance)
    
    return route_distances